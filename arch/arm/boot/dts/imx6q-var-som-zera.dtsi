/dts-v1/;

#include "imx6q.dtsi"
#include "imx6qdl-var-som.dtsi"
#include <dt-bindings/input/linux-event-codes.h>
#include <dt-bindings/gpio/gpio.h>

/ {
	model = "ZERA i.MX6 VAR-SOM-MX6";
	compatible = "variscite,var-som", "fsl,imx6q";

	/* ZERA */
	gpio-keys {
		compatible = "gpio-keys";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_gpio_keys>;

		power-button {
			label = "Power Button";
			gpios = <&gpio5 20 GPIO_ACTIVE_LOW>;
			linux,code = <KEY_POWER>;
			gpio-key,wakeup;
		};
		power-down {
			label = "Power Down";
			gpios = <&gpio5 21 GPIO_ACTIVE_LOW>;
			linux,code = <KEY_POWER>;
			gpio-key,wakeup;
		};
	};

	/* Variscite */
	reg_usb_otg_vbus: regulator-usbotgvbus {
		compatible = "regulator-fixed";
		regulator-name = "usb_otg_vbus";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		regulator-always-on;
	};
	reg_usb_h1_vbus: regulator-usbh1vbus {
		compatible = "regulator-fixed";
		regulator-name = "usb_h1_vbus";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		gpio = <&gpio4 15 GPIO_ACTIVE_HIGH>;
		enable-active-high;
		regulator-always-on;
	};

	sound {
		compatible = "simple-audio-card";
		simple-audio-card,name = "tlv320aic3106-audio";
		simple-audio-card,format = "i2s";
		simple-audio-card,bitclock-master = <&sound_codec>;
		simple-audio-card,frame-master = <&sound_codec>;
		simple-audio-card,widgets = "Headphone", "Headphone Jack",
					    "Line", "Line In";
		simple-audio-card,routing = "Headphone Jack", "HPLOUT",
					    "Headphone Jack", "HPROUT",
					    "LINE1L", "Line In",
					    "LINE1R", "Line In";

		sound_cpu: simple-audio-card,cpu {
			sound-dai = <&ssi2>;
		};

		sound_codec: simple-audio-card,codec {
			sound-dai = <&tlv320aic3106>;
			clocks = <&clks IMX6QDL_CLK_CKO>;
		};
	};
};


/* pinmuxing

    howto:
        1. check i.MX6 Dual/Quad Application Reference Manual / chapter 4.1.2 / e.g 'EIM - External Interface Module'
           for pad name
        2. search arch/arm/boot/dts/imx6q-pinfunc.h for available pinmux names as 'MX6QDL_PAD_<pad name>_...' 
        3. select pinmux
           e.g EIM_DA0 -> MX6QDL_PAD_EIM_DA0__EIM_AD00
        4. look for pad CONFIG (=value we have to set here) register location 
           (2nd tupel entry in arch/arm/boot/dts/imx6q-pinfunc.h) e.g MX6QDL_PAD_EIM_DA0__EIM_AD00 -> 0x428
        5. search in Reference Manual for 20E_<pad config> (should be somewhere in Reference Manual chapter 36.4)
           e.g MX6QDL_PAD_EIM_DA0__EIM_AD00 -> 20E_0428
        6. setup pad config e.g  (see also Reference Manual chapter 28.4.2 for GPIO pin details on pull/keep and
           DSE+SRE+SPEED / operating frequency):
           for example:
                       0x1 b    0    b    1
                       0b1 1011 0000 1011 0001 means

           Bit 16    / 0b1 xxxx xxxx xxxx xxxx => 1:   Schmitt trigger enabled
           Bit 15-14 / 0bx 10xx xxxx xxxx xxxx => 10:  100K pull up
           Bit 13    / 0bx xx1x xxxx xxxx xxxx => 1:   pull selected
           Bit 12    / 0bx xxx1 xxxx xxxx xxxx => 1:   pull enabled
           Bit 11    / 0bx xxxx 0xxx xxxx xxxx => 0:   output is CMOS
           Bit 10-8  / 0bx xxxx x000 xxxx xxxx => 000: reserverd to 000
           Bit 7-6   / 0bx xxxx xxxx 10xx xxxx => 10:  speed (SPEED): medium 100,150MHz
           Bit 5-3   / 0bx xxxx xxxx xx11 0xxx => 110: drive strength (DSE): 25 Ohm @ 3,3V / 40 Ohm @ 1,8V
           Bit 2-1   / 0bx xxxx xxxx xxxx x00x => 00:  reserverd to 00
           Bit 0     / 0bx xxxx xxxx xxxx xxx1 => 1:   Slew rate (SRE): fast

           Note: see Reference Manual/Table 28-9 -> operating frequency 150MHz
*/

&iomuxc {
	/* Variscite */
	pinctrl_usdhc2cdwp: usdhc2cdwpgrp {
		fsl,pins = <
      /* SDMMC2 CD/WP */
      MX6QDL_PAD_KEY_COL4__GPIO4_IO14		0x80000000
      MX6QDL_PAD_KEY_ROW4__GPIO4_IO15		0x80000000
		>;
	};

	/* ZFPGA I/O */
	pinctrl_zfpgamux_1: zfpgamux-1 {
		fsl,pins = <
			MX6QDL_PAD_SD4_DAT6__GPIO2_IO14 0x1a8b1	   /* LCA_IRQ as open drain no pullup (external) */
			MX6QDL_PAD_SD4_DAT3__GPIO2_IO11 0x1b0b1	   /* LCA_DONE */
			MX6QDL_PAD_GPIO_2__GPIO1_IO02   0x80000000 /* LCA_RESET */
		>;
	};

	/* Power: Button / PowerSupply off detect */
	pinctrl_gpio_keys: gpio_keysgrp {
		fsl,pins = <
			/* PowerOn/Off buttons */
			MX6QDL_PAD_CSI0_DATA_EN__GPIO5_IO20 0x17059
			MX6QDL_PAD_CSI0_VSYNC__GPIO5_IO21   0x17059
		>;
	};

	/* ZFPGA WEIM */
	pinctrl_weim_zfpga: weim_zfpga-1 {
		fsl,pins = <
			/* EIM control outputs */
			MX6QDL_PAD_EIM_BCLK__EIM_BCLK    0x0b0b9
			MX6QDL_PAD_EIM_CS0__EIM_CS0_B    0x0b0b1
			MX6QDL_PAD_EIM_CS1__EIM_CS1_B    0x0b0b1
			MX6QDL_PAD_EIM_EB0__EIM_EB0_B    0x0b0b1
			MX6QDL_PAD_EIM_EB1__EIM_EB1_B    0x0b0b1
			MX6QDL_PAD_EIM_OE__EIM_OE_B      0x0b0b1
			MX6QDL_PAD_EIM_RW__EIM_RW        0x0b0b1
			MX6QDL_PAD_EIM_LBA__EIM_LBA_B    0x0b0b1

			/* EIM control inputs */
			MX6QDL_PAD_EIM_WAIT__EIM_DTACK_B 0x1b0b1

			/* EIM data/address */
			MX6QDL_PAD_EIM_DA0__EIM_AD00     0x1b0b1
			MX6QDL_PAD_EIM_DA1__EIM_AD01     0x1b0b1
			MX6QDL_PAD_EIM_DA2__EIM_AD02     0x1b0b1
			MX6QDL_PAD_EIM_DA3__EIM_AD03     0x1b0b1
			MX6QDL_PAD_EIM_DA4__EIM_AD04     0x1b0b1
			MX6QDL_PAD_EIM_DA5__EIM_AD05     0x1b0b1
			MX6QDL_PAD_EIM_DA6__EIM_AD06     0x1b0b1
			MX6QDL_PAD_EIM_DA7__EIM_AD07     0x1b0b1
			MX6QDL_PAD_EIM_DA8__EIM_AD08     0x1b0b1
			MX6QDL_PAD_EIM_DA9__EIM_AD09     0x1b0b1
			MX6QDL_PAD_EIM_DA10__EIM_AD10    0x1b0b1
			MX6QDL_PAD_EIM_DA11__EIM_AD11    0x1b0b1
			MX6QDL_PAD_EIM_DA12__EIM_AD12    0x1b0b1
			MX6QDL_PAD_EIM_DA13__EIM_AD13    0x1b0b1
			MX6QDL_PAD_EIM_DA14__EIM_AD14    0x1b0b1
			MX6QDL_PAD_EIM_DA15__EIM_AD15    0x1b0b1

			/* EIM address */
			MX6QDL_PAD_EIM_A20__EIM_ADDR20   0x0b0b1
			MX6QDL_PAD_EIM_A19__EIM_ADDR19   0x0b0b1
			MX6QDL_PAD_EIM_A18__EIM_ADDR18   0x0b0b1
			MX6QDL_PAD_EIM_A17__EIM_ADDR17   0x0b0b1
			MX6QDL_PAD_EIM_A16__EIM_ADDR16   0x0b0b1
		>;
	};
};

/* EIM settings - still have no idea why they call it 'wireless'... */
&weim {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_zfpgamux_1 &pinctrl_weim_zfpga>;

	#address-cells = <2>;
	#size-cells = <1>;
	/* address translation - friends are: Documentation/<..>/imx-weim.txt / `cat /proc/iomem` /
		 i.MX 6Dual/6Quad Applications Processor Reference Manual chapter 2 'Memory Maps' -> EIM
		 to get CS working properly with weim-cs-gpr, the values here are fixed for number of CS
		 used */
	ranges = <0 0 0x08000000 0x04000000     // CS0
	          1 0 0x0C000000 0x04000000>;   // CS1
	fsl,weim-cs-gpr = <&gpr>;
    
	/* ??? TODO: pin conflict with ecspi1, i2c3 and uart3 ??? */
	status = "okay";

	/* CS0 */
	zfpga@0,0 {
		compatible = "zera,zfpga-1";
		/* CS0/StartAddrNode1/LengthNode1 / CS0/StartAddrNode2/LengthNode2 / ... */
		reg = <0 0x00000000 0x00001000   /* reg1 */
			0 0x00001000 0x00000020   /* dsp1 */
			0 0x00001400 0x00000020   /* dsp2 */
			0 0x00002000 0x00000001   /* boot */
			0 0x00003000 0x00001000   /* ec1  */
			0 0x00004000 0x00001000   /* msg1  */
			0 0x00010000 0x00010000>;   /* dbg  */
			
		fsl,weim-cs-timing = <0x01a10c09 0x00001100 /* EIM Chip-Select n General Configuration Register 1&2 */
			0x08023101 0x00000008 /* EIM Chip-Select n Read Configuration Register 1&2 */
			0x08049681 0x00000000 /* EIM Chip-Select n Write Configuration Register 1&2 */ >;

		/* device nodes/files (nodetype: 0:boot 1:reg 2:dsp 3:ec 4:msg 5:dbg 6:source) */
		reg1 {
			nodename = "zFPGA1reg";
			nodetype = <1>;
			interrupt-parent = <&gpio2>;
			/* interrupts: tupels of pin no / interrupt type (see
			Documentation/devicetree/bindings/gpio/fsl-imx-gpio.txt) */
			interrupts = <14 8>; /* low level triggered to ensure firing until all handled */
			/* align endianess for all access withs (EIM has special ideas for 32Bit access) */
			endian32 = /bits/ 8 <2 3 0 1>;
		};
		dsp1 {
			nodename = "zFPGA1dsp1";
			nodetype = <2>;
			interrupt-parent = <&gpio2>;
			/* interrupts: tupels of pin no / interrupt type (see
			Documentation/devicetree/bindings/gpio/fsl-imx-gpio.txt) */
			interrupts = <14 8>; /* low level triggered to ensure firing until all handled */
			/* align endianess for all access withs (EIM has special ideas for 32Bit access) */
			endian32 = /bits/ 8 <2 3 0 1>;
		};
		dsp2 {
			nodename = "zFPGA1dsp2";
			nodetype = <2>;
			interrupt-parent = <&gpio2>;
			/* interrupts: tupels of pin no / interrupt type (see
			Documentation/devicetree/bindings/gpio/fsl-imx-gpio.txt) */
			interrupts = <14 8>; /* low level triggered to ensure firing until all handled */
			/* align endianess for all access withs (EIM has special ideas for 32Bit access) */
			endian32 = /bits/ 8 <2 3 0 1>;
		};
		boot1 { /* there is only one boot device allowed currently */
			nodename = "zFPGA1boot";
			nodetype = <0>;
			bytes-per-transaction = <4>;
			/* gpio: tupel of port/pin/flag - note that flag is ignored */
			gpio-reset = <&gpio1 2  GPIO_ACTIVE_HIGH>;
			gpio-done =  <&gpio2 11 GPIO_ACTIVE_HIGH>;	/* is neccessary as it is read in interrupt service */
			interrupt-parent = <&gpio2>;
			/* interrupts: tupels of pin no / interrupt type (see
			Documentation/devicetree/bindings/gpio/fsl-imx-gpio.txt) */
			interrupts = <11 3>; /* both edges triggered */
			/* align endianess for all access withs (EIM has special ideas for 32Bit access) */
			endian32 = /bits/ 8 <2 3 0 1>;
		};
		ec1 {
			nodename = "zFPGA1ec";
			nodetype = <3>;
			interrupt-parent = <&gpio2>;
			/* interrupts: tupels of pin no / interrupt type (see
			Documentation/devicetree/bindings/gpio/fsl-imx-gpio.txt) */
			interrupts = <14 8>; /* low level triggered to ensure firing until all handled */
			/* align endianess for all access withs (EIM has special ideas for 32Bit access) */
			endian32 = /bits/ 8 <2 3 0 1>;
		};
		msg1 {
			nodename = "zFPGA1msg";
			nodetype = <4>;
			interrupt-parent = <&gpio2>;
			/* interrupts: tupels of pin no / interrupt type (see
			Documentation/devicetree/bindings/gpio/fsl-imx-gpio.txt) */
			interrupts = <14 8>; /* low level triggered to ensure firing until all handled */
			/* align endianess for all access withs (EIM has special ideas for 32Bit access) */
			endian32 = /bits/ 8 <2 3 0 1>;
		};
		dbg1 {
			nodename = "zFPGA1dbg";
			nodetype = <5>;
			/* align endianess for all access withs (EIM has special ideas for 32Bit access) */
			endian32 = /bits/ 8 <2 3 0 1>;
		};
	};
	
	/* CS1 */
	zfpga@1,0 {
		compatible = "zera,zfpga-1";
		/* CS0/StartAddrNode1/LengthNode1 / CS0/StartAddrNode2/LengthNode2 / ... */
		reg = <1 0x00000000 0x00070000>; /* source */
					
		fsl,weim-cs-timing = <0x71813C3F 0x00001002 /* EIM Chip-Select n General Configuration Register 1&2 */
			0x03000000 0x00000000 /* EIM Chip-Select n Read Configuration Register 1&2 */
			0x02040000 0x00000000 /* EIM Chip-Select n Write Configuration Register 1&2 */ >;
        
        fsl,burst-clk-enable;
				
		source1 {
			nodename = "zFPGA1source";
			nodetype = <6>;
			interrupt-parent = <&gpio2>;
			/* interrupts: tupels of pin no / interrupt type (see
			Documentation/devicetree/bindings/gpio/fsl-imx-gpio.txt) */
			interrupts = <14 8>; /* low level triggered to ensure firing until all handled */
			/* align endianess for all access withs (EIM has special ideas for 32Bit access) */
			endian32 = /bits/ 8 <2 3 0 1>;
		};
	};
};

/* Variscite defaults */
&ecspi1 {
	cs-gpios = <&gpio4 9 GPIO_ACTIVE_HIGH>,
		   <&gpio4 10 GPIO_ACTIVE_HIGH>;
	status = "okay";
};

&fec {
	status = "okay";
};

&hdmi {
	status = "okay";
};

/* is free on starterkit - so it remains disabled */
&i2c1 {
	status = "okay";
};

&i2c3 {
	status = "okay";
	rtc@0x68 {
		compatible = "dallas,ds1337";
		reg = <0x68>;
	};
};

&pwm2 {
	status = "okay";
};

&uart1 {
	status = "okay";
};

/*&uart3 {
	status = "okay";
};*/

&usbotg {
	pinctrl-names = "default";
	vbus-supply = <&reg_usb_otg_vbus>;
	disable-over-current;
	dr_mode = "host";
	status = "okay";
};

&usbh1 {
	vbus-supply = <&reg_usb_h1_vbus>;
	status = "okay";
};

&usdhc2 {
	pinctrl-names = "default";
	pinctrl-1 = <&pinctrl_usdhc2cdwp>;
	cd-gpios = <&gpio4 14 GPIO_ACTIVE_LOW>;
	/*wp-gpios = <&gpio4 15 GPIO_ACTIVE_HIGH>;*/
	status = "okay";
};

